# `$` variables

[BLOG](http://c.biancheng.net/cpp/view/2739.html)



# Branches

## `case ... esac`

[ref: case](https://linuxize.com/post/bash-case-statement/)

Note: `;;` is like `break` in C, and `;&` is like 'fallthrough' in C.



## `if ... fi`

### syntax

```bash
if [ <some test> ];then
	<commands>
elif [ <some test> ];then
	<different commands>
else
	<other commands>
fi
```



### Condition expression

[ref: GNU](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html)



# Command-line arguments parsing

## `getopts`

[ref: Small getopts tutorial at Bash Hackers Wiki](https://wiki.bash-hackers.org/howto/getopts_tutorial)



### Used variables

There are some variables `getopts` will use, listed below:

| variable                                                     | description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [OPTIND](https://wiki.bash-hackers.org/syntax/shellvars#optind) | Holds the index to the next argument to be processed. This is how `getopts` "remembers" its own status between invocations. Also useful to shift the positional parameters after processing with `getopts`. `OPTIND` is initially set to 1, and **needs to be re-set to 1 if you want to parse anything again with getopts** |
| [OPTARG](https://wiki.bash-hackers.org/syntax/shellvars#optarg) | This variable is set to any argument for an option found by `getopts`. It also contains the option flag of an unknown option. |
| [OPTERR](https://wiki.bash-hackers.org/syntax/shellvars#opterr) | (Values 0 or 1) Indicates if Bash should display error messages generated by the `getopts` builtin. The value is initialized to **1** on every shell startup - so be sure to always set it to **0** if you don't want to see annoying messages! **`OPTERR` is not specified by POSIX for the `getopts` builtin utility â€” only for the C `getopt()`function in `unistd.h` (`opterr`).** `OPTERR` is bash-specific and not supported by shells such as ksh93, mksh, zsh, or dash. |

In short: `OPTIND` is used to point out the position of **next** argument to take, `OPTARG` is set to the argument `getopts` **taked last time** (an argument if possible).



### Syntax

The syntax of `getopts` is :

```shell
getopts OPTSTRING VARNAME [ARGS...]
```

where:

| Pattern     | function                                                     |
| ----------- | ------------------------------------------------------------ |
| `OPTSTRING` | tells `getopts` which options to expect and where to expect arguments (see below) |
| `VARNAME`   | tells `getopts` which shell-variable to use for option reporting |
| `ARGS`      | tells `getopts` to parse these optional words instead of the positional parameters |

`ARGS` is always omitted when parsing arguments from terminal.



#### effect of `OPTSTRING`

The option-string tells `getopts` which options to expect and which of them must have an argument. The syntax is very simple: every option character is simply named as is, this example-string would tell `getopts` to look for `-f`, `-A` and `-x`:

```shell
getopts fAx VARNAME
```

When you want `getopts` to expect an argument for an option, just place a `:` (colon) **after** the proper option flag. If you want `-A` to expect an argument (i.e. to become `-A SOMETHING`) just do:

```shell
getopts fA:x VARNAME
```



If the **very first character** of the option-string is a `:` (colon), which would normally be nonsense because there's no option letter preceding it, `getopts` switches to "**silent error reporting mode**". In productive scripts, this is usually what you want because it allows you to handle errors yourself without being disturbed by annoying messages.



#### effect of `ARGS`

When omitted, `ARGS` is set to `"$@"`, see [What is $@ in Bash - stackoverflow](https://stackoverflow.com/questions/3898665/what-is-in-bash) for more details.

An example when getting options from your string:

```shell
OPTINDOLD=$OPTIND  # store $OPTIND
OPTIND=1
while getopts "abc" opt "-a" "-b" "-c";do
...
done
OPTIND=$OPTINDOLD  # restore $OPTIND
```

because `optgets` relies on `$OPTIND` to index the command-line paraments to take.



### When to stop parse arguments and the exit status

`getopts` will parse options and their possible arguments. It will stop parsing on the first non-option argument (a string that doesn't begin with a hyphen (`-`) that isn't an argument for any option in front of it). It will also stop parsing when it sees the `--` (double-hyphen), which means [end of options](https://wiki.bash-hackers.org/dict/terms/end_of_options).



`getopts` sets an exit status of `FALSE` when there's nothing left to parse, so it is easy to use in a while-loop:

```shell
while getopts ...;do
done
```



### Example

```shell
#!/bin/bash
 
while getopts ":ab:" opt; do
	case $opt in
		a)
			echo "-a was triggered!" >&2
			;;
		\?)  # opt will equal to "?" if there is no valid option to take
			echo "Invalid option: -$OPTARG" >&2
			;;
		:)
			echo "Option -$OPTARG requires an argument." >&2
			exit 1
		;;
		esac
done
```

```sh
$ ./go_test.sh -a -x -b -c -b
-a was triggered!
Invalid option: -x
Invalid option: -b
Invalid option: -c
Option -b requires an argument.
$ 
```



# Shell Parameter Expansion

[ref: intro in GNU](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)



# Skills of commands

## `echo`

[echo colored text](https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux)



## echo running command

[ref: Stackoverflow](https://stackoverflow.com/questions/2853803/how-to-echo-shell-commands-as-they-are-executed)

`set -x` will let all command below displayed. `set +x` will cancel it but itself is printed as well.

`( set -x ; XXX )` can display the `XXX` commnad only.